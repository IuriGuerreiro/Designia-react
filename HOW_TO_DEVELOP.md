# Designia React Development Guide

This guide outlines the day-to-day workflow for contributing to the Designia React application. It captures the current project layout, conventions, and local commands that keep the developer experience consistent across the team.

## Prerequisites

- **Node.js 18+** (the project targets modern ES2022 features).
- **npm 9+** (ships with recent Node versions).
- Recommended: install the [Vite](https://vitejs.dev) and [TypeScript](https://www.typescriptlang.org) VS Code extensions for instant feedback.

Install dependencies once after cloning:

```bash
npm install
```

## Core scripts

| Purpose            | Command          | Notes |
|--------------------|------------------|-------|
| Start local dev    | `npm run dev`    | Boots Vite on port **5173** with hot module replacement. |
| Type-check & build | `npm run build`  | Runs `tsc -b` followed by the Vite production build. This currently reports TypeScript errors in legacy modules; use `npm run dev` for active work until those debt items are resolved. |
| Linting            | `npm run lint`   | Executes the ESLint config stored in `eslint.config.js`. |
| Preview build      | `npm run preview`| Serves the production bundle generated by `npm run build`. |

> **Known issue:** `npm run build` is expected to fail while older TypeScript debt is still being retired. Focus on `npm run dev` for day-to-day development and track build health regularly.

## Project layout

The source tree follows an enterprise-style modular structure:

```
src/
├── app/          # Application shell: providers, layout, routing, error boundaries
├── features/     # Domain-oriented slices (auth, marketplace, chat, admin, account, payments, etc.)
│   └── <feature>/
│       ├── api/          # Feature-specific HTTP clients & adapters
│       ├── components/   # Presentational building blocks unique to the feature
│       ├── hooks/        # Reusable hooks exposed by the feature
│       ├── model/        # Types, constants, and state machines/entities
│       ├── routes.tsx    # Route registrations for the feature
│       └── index.ts      # Public surface of the feature
├── pages/        # Top-level pages that pre-date the feature split (in flight to migrate)
├── shared/       # Cross-cutting infrastructure (api clients, shared state, reusable UI primitives)
├── styles/       # Global stylesheets (`global.css`) and shared tokens
└── utils/        # Generic utilities that are feature-agnostic
```

### Feature conventions

- **Routing:** Each feature exposes its own `routes.tsx` that exports route definitions consumed by `src/app/router/AppRouter.tsx`.
- **State:** Long-lived context or state machines live under `state/` inside the feature and are wired via providers in `src/app/providers/AppProviders.tsx`.
- **APIs:** Use the shared `src/shared/api/httpClient.ts` helper to create typed clients. Keep endpoint constants in `src/shared/api/endpoints.ts`.
- **Exports:** Re-export the feature public API from `index.ts` so other modules can import via `@/features/<feature>`.

### Styling standards

- Use **CSS Modules** (`*.module.css`) for feature-specific styling.
- Place shared, non-namespaced design tokens in `src/styles/global.css`. This file is imported once in `src/main.tsx`.
- When migrating legacy components, move their CSS alongside the component within the feature.

## Working with aliases

Path aliases are configured via `tsconfig.app.json` and `vite.config.ts`:

- Use `@/` to reference anything under `src/`. For example, import the auth context with `import { AuthProvider } from "@/features/auth";`.
- Avoid deep relative paths (`../../../`) when the alias is available.

## Adding a new feature

1. Create a folder under `src/features/<feature-name>/` with the subfolders you need (`api`, `components`, `hooks`, `model`, etc.).
2. Define any new routes in `routes.tsx` and export them via `index.ts`.
3. Register the feature’s routes in `src/app/router/AppRouter.tsx` or compose them into existing route groups.
4. Add providers or contexts to `src/app/providers/AppProviders.tsx` if the feature exposes global state.
5. Use the shared HTTP client (`src/shared/api/httpClient.ts`) and endpoint helpers for API access.
6. Document any new environment variables in the project README.

## Code review checklist

- [ ] Imports prefer the `@/` alias and avoid unused exports.
- [ ] CSS follows the module/global split described above.
- [ ] Domain logic stays inside feature folders—no leaking into `src/shared` unless it’s cross-cutting.
- [ ] Added UI respects existing accessibility patterns (semantic headings, labelled controls).
- [ ] Run `npm run dev` to ensure the app boots cleanly before submitting changes.

Keeping these guidelines in mind ensures the codebase remains modular, testable, and approachable as the project scales.
